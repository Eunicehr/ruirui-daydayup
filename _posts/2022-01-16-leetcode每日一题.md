---

layout: post
title: " leetcode每日一题"
date:   2022-01-16
categories: [python]
tags: [leetcode每日一题]
pinned: false
toc: true
author: cute-rui
---



# leetcode每日一题

## 1.11

### 两数之和

- 题目

  ![image-20220112172016990](https://s2.loli.net/2022/01/12/lTESyCzU9owi8nm.png)

  ```python
  class Solution:
      def twoSum(self,nums, target):
          n = len(nums)
          for x in range(n):
              for y in range(x+1,n):
                  if nums[x]+nums[y] == target :
                      return x,y
  ```

  

- 注意点：

  - `Tab`向右缩进，`shift+Tab`向左缩进

    ```python
    #python3的格式
    class Solution:
        def twoSum(self, nums: List[int], target: int) -> List[int]:
        
    #python2的格式
    class Solution(object):
        def twoSum(self, nums, target):
            """
            :type nums: List[int]
            :type target: int
            :rtype: List[int]
            """
    ```
  
    
  
    
  

## 1.12

### 回文数

- 题目

  ![image-20220112163355680](https://s2.loli.net/2022/01/12/HDlO273mpx6BTsG.png)

  ```python
  class Solution:
      def isPalindrome(self, x: int) -> bool:
          a=str(x)
          if a[0]!=0:
              b=a[::-1]
              if a==b:
                  return True
              else:
                  return False
          else:
              return False
  ```

  

- 注意点：python 中[:-1]和[::-1]的区别：

  - [::-1] 顺序相反操作，[:-1] 读取倒数第一个元素

    ```python
    a='python'
    b=a[::-1]
    print(b) #nohtyp
     
    c=a[::-2]
    print(c) #nhy
     
    d=a[:-1]  #从位置0到位置-1之前的数
    print(d)  #pytho
     
    e=a[:-2]  #从位置0到位置-2之前的数
     
    print(e)  #pyth
    ```

  - [::-2]表示从最后一个元素以步长为二向前读取元素

    [1:4:2]表示从第一个元素以步长为二向后读取到第三个元素

  

  


##1.13

### 至少是其他数字两倍的最大数

题目：

![image-20220113103540152](https://s2.loli.net/2022/01/13/KEFqUQWuygliCXp.png)

思路：先用max函数找到列表中的最大值，然后遍历列表，记录下最大值的索引，当列表中的数字不满足条件时，直接返回-1

```python
class Solution:
    def dominantIndex(self, nums: List[int]) ->int:
        flag=-1
        m=max(nums)
        for i in range(len(nums)):
            if nums[i]==m:
                flag=i
            if nums[i]!=m and nums[i]*2>m:
                return -1
        return flag
```



### 二叉树的中序遍历

题目：

![image-20220113191944604](https://s2.loli.net/2022/01/13/TnKi3kcDYWjrp2H.png)

![image-20220113192014463](https://s2.loli.net/2022/01/13/pXVrQgP458ecjIO.png)

![image-20220113192036674](https://s2.loli.net/2022/01/13/DBhV6CqNE9KULTY.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if root==None:
            return []
        else:
            self.inorderTraversal(root.left)
            self.inorderTraversal(root.right)
        return self.inorderTraversal(root.left)+[root.val]+ self.inorderTraversal(root.right)
```

### 二叉树的最大深度

题目:

![image-20220113191849497](https://s2.loli.net/2022/01/13/C9AloJ6SWUINXVr.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root==None:
            return 0
        else:
            l=1+self.maxDepth(root.left)
            r=1+self.maxDepth(root.right)
        return max(l,r)
```

### 最大共同前缀

题目：

![image-20220113215011583](https://s2.loli.net/2022/01/13/i9Pq8TfUVhANzmC.png)

- 方法一:横向扫描

![image-20220114001206621](https://s2.loli.net/2022/01/14/8vcGgMJjQftoeDq.png)

思路：如果字符串列表为空，返回""；将第一个字符串和第二个字符串求共同前缀，然后再将之前求到的共同前缀和第三个字符串求共同前缀,如此反复直到最后一个。第一个字符串的第一个字符如果和第二个字符串的第一个字符相同，就将第一个字符记作共同前缀，第二个字符如果仍相同，则将第二个字符也记录进之前求得的共同前缀中，直到出现不同的字符。

```python
def f(a:str,b:str)->str:
    "返回两个字符串的最长前缀"
    if len(a)>len(b):
        n=len(b)
    else:
        n=len(a)
    x=''
    for i in range(n):
        if a[i]==b[i]:
            x=x+a[i]
        else:
            break
    return x
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if strs==None:
            return ''
        if len(strs)==1:
            return strs[0]
        	x=f(strs[0],strs[1])#将第一个字符串和第二个字符串求共同前缀
		#将之前求到的共同前缀和第三个字符串求共同前缀,如此反复直到最后一个
        for i in range(2,len(strs)):
            x=f(x,strs[i])
        return x
            
```

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        prefix, count = strs[0], len(strs)
        for i in range(1, count):
            prefix = self.lcp(prefix, strs[i])
            if not prefix:
                break
        
        return prefix

    def lcp(self, str1, str2):
        length, index = min(len(str1), len(str2)), 0
        while index < length and str1[index] == str2[index]:
            index += 1
        return str1[:index]
```

时间复杂度：O(mn)，其中 mm 是字符串数组中的字符串的平均长度，nn 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。

空间复杂度：O(1)。使用的额外空间复杂度为常数。

- 方法二：纵向扫描

  思路：纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。

  ![image-20220113235647418](https://s2.loli.net/2022/01/13/Dn6gPEiC1qdhMm4.png)

  ```python
  class Solution:
      def longestCommonPrefix(self, strs: List[str]) -> str:
          if not strs:
              return ""
          
          length, count = len(strs[0]), len(strs)
          for i in range(length):
              c = strs[0][i]
              if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):
                  return strs[0][:i]
          
          return strs[0]
  ```

  时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，nn是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。

  空间复杂度：O(1)。使用的额外空间复杂度为常数。

## 1.14

### 罗马数字转整数

题目：

![image-20220114181556038](https://s2.loli.net/2022/01/14/4fX6UMSbzRsiQ1h.png)

![image-20220114181616397](https://s2.loli.net/2022/01/14/zCT81aIol7QOF3h.png)

![image-20220114181639685](https://s2.loli.net/2022/01/14/tbKdEITwFNrxGuQ.png)

思路：如果当前的字符小于它后面的字符，就把这两个字符看作一个整体，值为后面的那个字符减去前面那个字符。如果当前的字符大于它后面的字符，值为每一位的字符的值相加

```python
class Solution:
    def romanToInt(self, s: str) -> int:
        val={
            "I":1,
            "V":5,
            "X":10,
            "L":50,
            "C":100,
            "D":500,
            "M":1000,
        }
        t=0
        i=0 ##当前看的是第几位罗马数字
        while i<len(s):
            if  i+1<len(s) and val[s[i]]<val[s[i+1]]:
                t=t+val[s[i+1]]-val[s[i]]
                i=i+2
            else:
                t=t+val[s[i]]
                i=i+1
        return t
```

注意点：i+1<len(s)

### 有效的括号

题目:

![image-20220114091411965](https://s2.loli.net/2022/01/14/cvUfsYWySowthAM.png)

![image-20220114091518735](https://s2.loli.net/2022/01/14/2IFhN3Ggd7p8BXP.png)

思路：如果是左括号，则将其压入栈；如果是右括号，则将左括号出栈，判断出栈的左括号能否与右括号匹配。最后判断栈是否被清空

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]
        for char in s:
            if char in {"(","[","{"}:
                stack.append(char)
            else:
                if not stack:
                    return False
                x=stack.pop()
                if char==")" and x!="(":
                    return False
                if char=="]" and x!="[":
                    return False
                if char=="}" and x!="{":
                    return False
        return len(stack)==0
          
```

注意点：空列表不等于None



## 1.15

### 实现strStr()

题目：

![image-20220115075333231](https://s2.loli.net/2022/01/15/Bq2NXxk8gRolZd1.png)

![image-20220115075357719](https://s2.loli.net/2022/01/15/c8Z2mpBM3AN9tya.png)

思路：

直接在haystack中找needle

```pyhton
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        for i in range (len(haystack)-len(needle)+1):
            if haystack[i:i+len(needle)]==needle:
                return i
        return -1

```



### 加一

题目：

![image-20220115090440242](https://s2.loli.net/2022/01/15/1xDydMSY9NjH4Ve.png)

![image-20220115090501054](https://s2.loli.net/2022/01/15/5LQNoJaMFWXYVkE.png)

思路：

```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        for i in reversed(range(len(digits))):
            if digits[i]==9:
                digits[i]=0
            else:
                digits[i]=digits[i]+1
                return digits
        digits[0]=1
        digits.append(0)
        return digits
```

注意点:1. 最后三句在for循环里面！！！

​            2.学会断点调试



### 杨辉三角

题目：

![image-20220115112752634](https://s2.loli.net/2022/01/15/PiatvZTF8lcbXYm.png)

![image-20220115112826648](https://s2.loli.net/2022/01/15/GvOUIr5ADQjNeht.png)

思路：每一行的第一个和最后一个元素是1，其他位置等于上一行前一列的元素与上一行同列的元素相加

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        result=[]
        for i in range(numRows):
            result.append([])
            for j in range(i+1):
                if j in(0,i):
                    result[i].append(1)
                else:
                    result[i].append(result[i-1][j-1]+result[i-1][j])
        return result
```





## 1.16



### 最后一个单词的长度

题目：

![image-20220116145505021](https://s2.loli.net/2022/01/16/wobuPA1kUlFINVC.png)

![image-20220116145536795](https://s2.loli.net/2022/01/16/ChZFVdR3EL4fJem.png)

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        p=len(s)
        length=0
        while p>0:
            p=p-1
            if s[p]!=" ":
                length=length+1
            elif length>0:
                return length
        return length
```



### 七进制数

题目:

![image-20220116151733706](https://s2.loli.net/2022/01/16/LHX5j2qm6ibNsK1.png)

思路：分十进制数大于零，等于0，小于0三种情况

```python
class Solution:
    def convertToBase7(self, num: int) -> str:
        if num==0:
            return"0"
        old_num=num
        num=abs(num)
        res=""
        while num!=0:
            temp=num%7
            num=num//7
            res=res+str(temp)
        if old_num<0:
            return "-"+res[::-1] 
        return res[::-1] 
```



### 买卖股票的最佳时机

题目：

![image-20220116163548078](https://s2.loli.net/2022/01/16/8CpsBLowJkfxjhi.png)

思路：将初始最大利润设为0，最低买入价格设为无限大。将数组中读取的价格和初始最低买入价格比较，取最小的；更新的利润；更新最大利润。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit=0
        min_price=float('inf')
        for i in prices:
            min_price=min(min_price,i)
            update_profit=i-min_price
            max_profit=max(max_profit,update_profit)
        return max_profit
```





